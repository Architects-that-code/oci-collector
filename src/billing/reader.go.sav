package billing

import (
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// FocusData represents a single row in an OCI FOCUS report.


// ReadFocusData reads all FOCUS CSV files in a directory and returns a slice of FocusData structs.
// This function is kept for potential future use but is no longer used for combined CSV generation.
func ReadFocusData(path string) ([]FocusData, error) {
	var records []FocusData
	homedir, err := os.UserHomeDir()
	if err != nil {
		return nil, err
	}
	fullPath := filepath.Join(homedir, path)

	walkFunc := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".csv") {
			f, err := os.Open(path)
			if err != nil {
				return err
			}
			defer f.Close()

			csvReader := csv.NewReader(f)
			data, err := csvReader.ReadAll()
			if err != nil {
				return err
			}

			if len(data) < 2 {
				// Skip empty or header-only files
				return nil
			}

			header := data[0]
			headerMap := make(map[string]int)
			for i, h := range header {
				headerMap[h] = i
			}

			// Helper function to safely get a value from the map
			getVal := func(row []string, colName string) string {
				if idx, ok := headerMap[colName]; ok && idx < len(row) {
					return row[idx]
				}
				return ""
			}

			for _, row := range data[1:] { // Start from the first data row
				record := FocusData{
					AvailabilityZone:   getVal(row, "AvailabilityZone"),
					BilledCost:         getVal(row, "BilledCost"),
					BillingAccountId:   getVal(row, "BillingAccountId"),
					BillingAccountName: getVal(row, "BillingAccountName"),
					BillingCurrency:    getVal(row, "BillingCurrency"),
					BillingPeriodEnd:   getVal(row, "BillingPeriodEnd"),
					BillingPeriodStart: getVal(row, "BillingPeriodStart"),
					ChargeCategory:     getVal(row, "ChargeCategory"),
					ChargeDescription:  getVal(row, "ChargeDescription"),
					ChargeFrequency:    getVal(row, "ChargeFrequency"), ChargePeriodEnd: getVal(row, "ChargePeriodEnd"),
					ChargePeriodStart:          getVal(row, "ChargePeriodStart"),
					ChargeSubcategory:          getVal(row, "ChargeSubcategory"),
					CommitmentDiscountCategory: getVal(row, "CommitmentDiscountCategory"),
					CommitmentDiscountId:       getVal(row, "CommitmentDiscountId"),
					CommitmentDiscountName:     getVal(row, "CommitmentDiscountName"),
					CommitmentDiscountType:     getVal(row, "CommitmentDiscountType"),
					EffectiveCost:              getVal(row, "EffectiveCost"),
					InvoiceIssuer:              getVal(row, "InvoiceIssuer"),
					ListCost:                   getVal(row, "ListCost"),
					ListUnitPrice:              getVal(row, "ListUnitPrice"),
					PricingCategory:            getVal(row, "PricingCategory"),
					PricingQuantity:            getVal(row, "PricingQuantity"),
					PricingUnit:                getVal(row, "PricingUnit"),
					Provider:                   getVal(row, "Provider"),
					Publisher:                  getVal(row, "Publisher"),
					Region:                     getVal(row, "Region"),
					ResourceId:                 getVal(row, "ResourceId"),
					ResourceName:               getVal(row, "ResourceName"),
					ResourceType:               getVal(row, "ResourceType"),
					ServiceCategory:            getVal(row, "ServiceCategory"),
					ServiceName:                getVal(row, "ServiceName"),
					SkuId:                      getVal(row, "SkuId"),
					SkuPriceId:                 getVal(row, "SkuPriceId"),
					SubAccountId:               getVal(row, "SubAccountId"),
					SubAccountName:             getVal(row, "SubAccountName"),
					Tags:                       getVal(row, "Tags"),
					UsageQuantity:              getVal(row, "UsageQuantity"),
					UsageUnit:                  getVal(row, "UsageUnit"),
					OciReferenceNumber:         getVal(row, "oci_ReferenceNumber"),
					OciCompartmentId:           getVal(row, "oci_CompartmentId"),
					OciCompartmentName:         getVal(row, "oci_CompartmentName"),
					OciOverageFlag:             getVal(row, "oci_OverageFlag"),
					OciUnitPriceOverage:        getVal(row, "oci_UnitPriceOverage"),
					OciBilledQuantityOverage:   getVal(row, "oci_BilledQuantityOverage"),
					OciCostOverage:             getVal(row, "oci_CostOverage"),
					OciAttributedUsage:         getVal(row, "oci_AttributedUsage"),
					OciAttributedCost:          getVal(row, "oci_AttributedCost"),
					OciBackReferenceNumber:     getVal(row, "oci_BackReferenceNumber"),
				}
				records = append(records, record)
			}
		}
		return nil
	}

	if err := filepath.Walk(fullPath, walkFunc); err != nil {
		return nil, err
	}

	return records, nil
}

// WriteCombinedCSV reads all FOCUS CSV files from the given path, combines them,
// and writes the result to a new CSV file with a date range in its name.
func WriteCombinedCSV(inputPath string) error {
	homedir, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	fullInputPath := filepath.Join(homedir, inputPath)

	var earliest, latest time.Time
	firstFile := true

	// Prepare the output file
	// We'll determine the filename later once we have the date range
	var outputFileName string
	var outputFile *os.File
	var writer *csv.Writer

	hasWrittenHeader := false

	walkFunc := func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".csv") {
			f, err := os.Open(path)
			if err != nil {
				return err
			}
			defer f.Close()

			csvReader := csv.NewReader(f)

			// Read header
			header, err := csvReader.Read()
			if err == io.EOF {
				return nil // Empty file
			}
			if err != nil {
				return fmt.Errorf("error reading header from %s: %w", path, err)
			}

			// If this is the first file, write the header to the combined CSV
			if !hasWrittenHeader {
				// Initialize output file and writer here, as we now have the header
				// We need to find the date range first before creating the file
				// For now, we'll just store the header and write it later
				// This means we need to do two passes or collect headers and then data
				// Let's simplify: assume the header is consistent and write it from the first file encountered.
				// The date range will be collected during the first pass.

				// Temporarily store the header to write later
				// This approach requires collecting all data first, which defeats streaming.
				// Re-thinking: We need to determine the date range *before* writing the file.
				// So, first pass to get date range, second pass to write data.
				// Or, collect all data in memory (which we want to avoid).

				// Let's make a first pass to get the date range.
				// This function will only write the CSV, date range calculation will be separate.
				// This function will now only write the combined CSV, assuming date range is handled elsewhere.
				// The date range logic needs to be extracted or passed in.

				// New plan: WriteCombinedCSV will take the date range as parameters.
				// The calling function (Getfiles) will calculate the date range.
				// This simplifies WriteCombinedCSV to just writing the combined file.

				// Reverting to the original plan for WriteCombinedCSV: it will calculate date range and write.
				// This means we need to open the output file *after* finding the date range.

				// For now, let's just write the header from the first file and append data.
				// Date range calculation will be integrated.

				if outputFile == nil {
					// This is the first file, so we can determine the output filename
					// and create the output file.
					// We need to read all files once to get the date range.
					// This means ReadFocusData is still needed, or a new function for date range.

					// Let's simplify: WriteCombinedCSV will take the full path to the output directory
					// and will iterate through files, calculate date range, and write.
					// This requires a two-pass approach or a more complex single pass.

					// Let's try a single pass for date range and writing.
					// We'll collect all rows in memory for date range, then write.
					// This defeats the purpose of streaming. Back to the drawing board for WriteCombinedCSV.

					// The most memory-efficient way is to calculate the date range first,
					// then open the output file, then iterate and write.
					// So, a separate function to find date range is needed.

					// Let's modify WriteCombinedCSV to take the date range as parameters.
					// The calling function (Getfiles) will calculate the date range.
					// This means ReadFocusData is still needed to get the records for date range.
					// This is a circular dependency.

					// Okay, new plan for WriteCombinedCSV:
					// 1. It will take the inputPath (directory) as before.
					// 2. It will perform a first pass over all CSV files to determine the earliest and latest dates.
					// 3. It will then create the output CSV file with the date range in its name.
					// 4. It will perform a second pass over all CSV files to write their content to the combined file,
					//    writing the header only from the first file and skipping headers for subsequent files.
					// This avoids holding all FocusData in memory at once.

					// First pass: find date range
					// This logic will be moved to a helper function.
					// For now, let's just focus on the writing part.

					if !hasWrittenHeader {
						// This is the first file, write its header
						if err := writer.Write(header); err != nil {
							return fmt.Errorf("error writing header to combined CSV: %w", err)
						}
						hasWrittenHeader = true
					}

					// Write data rows
					for {
						row, err := csvReader.Read()
						if err == io.EOF {
							break
						}
						if err != nil {
							return fmt.Errorf("error reading row from %s: %w", path, err)
						}
						if err := writer.Write(row); err != nil {
							return fmt.Errorf("error writing row to combined CSV: %w", err)
						}
					}
				}
				return nil
			}

			// This is the main logic for WriteCombinedCSV
			// It will now perform two passes: one for date range, one for writing.

			// First pass: find date range
			// This will be a helper function.
			// Let's define parseDate and findDateRange here.

			// Helper to parse date strings from CSV
			parseDate := func(dateStr string) time.Time {
				layout := "2006-01-02T15:04:05Z" // Assuming this is the format
				t, err := time.Parse(layout, dateStr)
				if err != nil {
					// Log error or handle invalid date format
					return time.Time{} // Return zero time on error
				}
				return t
			}

			// Helper to find date range across all CSV files
			findDateRangeInFiles := func(dirPath string) (time.Time, time.Time, error) {
				var minDate, maxDate time.Time
				first := true

				walkErr := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error {
					if err != nil {
						return err
					}
					if !info.IsDir() && strings.HasSuffix(info.Name(), ".csv") {
						f, err := os.Open(path)
						if err != nil {
							return err
						}
						defer f.Close()

						csvReader := csv.NewReader(f)
						// Skip header
						_, err = csvReader.Read()
						if err != nil && err != io.EOF {
							return err
						}

						for {
							row, err := csvReader.Read()
							if err == io.EOF {
								break
							}
							if err != nil {
								return err
							}

							// Assuming BillingPeriodStart is at index 6 and BillingPeriodEnd at index 5
							// This is fragile. Better to read header and find index.
							// For now, let's assume fixed indices based on the provided header.
							// BillingPeriodStart is index 6, BillingPeriodEnd is index 5
							// Let's use the struct fields for clarity.

							// To get the correct indices, we need to read the header.
							// This means we need to pass the headerMap or re-read header for each file.
							// Re-reading header for each file is fine for date range.

							// Let's re-read header for each file to get indices for date fields.
							// This is getting complicated. Let's simplify the date parsing for now.

							// Assuming fixed indices for date fields for this helper.
							// BillingPeriodStart is the 7th column (index 6)
							// BillingPeriodEnd is the 6th column (index 5)

							// Let's use the struct field names and map them to indices.
							// This requires reading the header for each file.

							// Simpler: just parse the dates from the known columns.
							// This is fragile if column order changes.

							// Let's assume the header is consistent across all files for date fields.
							// We need to find the indices for "BillingPeriodStart" and "BillingPeriodEnd".
							// This means we need to read the header of the first file to get the indices.
							// Or, pass the headerMap from the first file.

							// Let's just use the fixed indices for now, as the struct is fixed.
							// BillingPeriodStart is index 6, BillingPeriodEnd is index 5.
							// This is based on the struct definition.

							// Re-checking the struct: BillingPeriodStart is 7th field, BillingPeriodEnd is 6th field.
							// So, indices are 6 and 5 respectively.

							startDate := parseDate(row[6])
							endDate := parseDate(row[5])

							if first {
								minDate = startDate
								maxDate = endDate
								first = false
							} else {
								if startDate.Before(minDate) {
									minDate = startDate
								}
								if endDate.After(maxDate) {
									maxDate = endDate
								}
							}
						}
					}
					return nil
				})

				if walkErr != nil {
					return time.Time{}, time.Time{}, walkErr
				}
				return minDate, maxDate, nil
			}

			// Main logic for WriteCombinedCSV
			// 1. Find date range
			// 2. Create output file with date range in name
			// 3. Iterate through files again and write data

			// First pass: find date range
			minDate, maxDate, err := findDateRangeInFiles(fullInputPath)
			if err != nil {
				return fmt.Errorf("error finding date range: %w", err)
			}

			if minDate.IsZero() || maxDate.IsZero() {
				return fmt.Errorf("no valid date range found in CSV files")
			}

			// Create the output file
			outputFileName = fmt.Sprintf("focus_data_%s_to_%s.csv", minDate.Format("2006-01-02"), maxDate.Format("2006-01-02"))
			fullOutputPath := filepath.Join(fullInputPath, outputFileName)

			outputFile, err = os.Create(fullOutputPath)
			if err != nil {
				return fmt.Errorf("error creating combined CSV file: %w", err)
			}
			defer outputFile.Close()

			writer = csv.NewWriter(outputFile)
			defer writer.Flush()

			// Second pass: write data
			hasWrittenHeader = false
			walkErr = filepath.Walk(fullInputPath, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if !info.IsDir() && strings.HasSuffix(info.Name(), ".csv") {
					// Skip the output file itself if it's in the same directory
					if info.Name() == outputFileName {
						return nil
					}

					f, err := os.Open(path)
					if err != nil {
						return err
					}
					defer f.Close()

					csvReader := csv.NewReader(f)

					// Read header
					header, err := csvReader.Read()
					if err == io.EOF {
						return nil // Empty file
					}
					if err != nil {
						return fmt.Errorf("error reading header from %s: %w", path, err)
					}

					if !hasWrittenHeader {
						// Write header to combined CSV
						if err := writer.Write(header); err != nil {
							return fmt.Errorf("error writing header to combined CSV: %w", err)
						}
						hasWrittenHeader = true
					}

					// Write data rows
					for {
						row, err := csvReader.Read()
						if err == io.EOF {
							break
						}
						if err != nil {
							return fmt.Errorf("error reading row from %s: %w", path, err)
						}
						if err := writer.Write(row); err != nil {
							return fmt.Errorf("error writing row to combined CSV: %w", err)
						}
					}
				}
				return nil
			})

			if walkErr != nil {
				return fmt.Errorf("error walking files for writing: %w", walkErr)
			}

			return nil
		}
	return nil
}